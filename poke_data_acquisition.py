import re
import math
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib as plt
from matplotlib import pyplot as plt
from scipy.optimize import curve_fit

def load_dataframe(file):
    '''Loads and processes the raw ascii file and converts it into a useable dataframe. It removes the headers, empty lines scattered throughout, renames
    the headers, and adds a "sweep" clumn to determine what data belongs to what sweep and therefore what negative pressure.

    Inputs:
    file: ascii file generated by the electrophysiology recording software patchmaster.

    Outputs:
    df: organized and processed dataframe containing original file data along with a sweep number column'''

    with open(file, 'r') as fhand:
    #removes spaces and separates string at \n
        raw_file = fhand.read().strip().split('\n')

    line_index = []
    count = 0
    #finding the lines that are not headers/have text in them/are blank and indexing them
    for line in raw_file:
        if re.search(r'[a-z]+', line) == None:
            line_index.append(count)
        count += 1

    #picking out data lines and adding them to this new list of lists
    processed_file = [raw_file[i].strip().replace(" ", "").split(",") for i in line_index]

    #determining the number of sweeps
    #original file has title (1 line) and each sweep has a header (2 lines)
    nsweeps = int((len(raw_file) - len(processed_file)-1)/2)

    #determining column names based on the length of  processed_file[0]
    if len(processed_file[0]) == 5:
        colnames = ['index','ti','i','tp','poke_v']
    else:
        colnames = ['index','ti','i','tp','poke_v','tv','v']

    df = pd.DataFrame(columns = colnames, data = processed_file)
    df = df.apply(pd.to_numeric)
    df = df.dropna(axis=0)

    #adding in sweeps
    datapoint_per_sweep = len(df) / nsweeps
    df['sweep'] = np.repeat(np.arange(nsweeps), datapoint_per_sweep)

    #converting values to more user friendly units
    df['poke_v'] = df['poke_v'] / 0.02
    df['ti'] *= 1000
    df['i'] *= 1e12 * -1
    df['tp'] *= 1000
    return(df)

def  parameter_processing(df, first_poke, cap, time_past, series_r, pip_r, cell_class):
    #deletes last sweep assuming trials are being run until the seal breaks
    final_sweep_num = df['sweep'].max()
    df = df.loc[(df['sweep'] != final_sweep_num) & (df['sweep'] >= first_poke)].copy()
    # df = df.loc[(df['sweep'] <= 9) & (df['sweep'] >= first_poke)].copy()
    df['indentation'] = df['sweep'] - first_poke + 1
    cap_list = [cap] * len(df)
    time_list = [time_past] * len(df)
    series_r_list = [series_r] * len(df)
    pip_r_list = [pip_r] * len(df)
    cell_class_list = [cell_class] *len(df)
    df['capacitance'] = cap_list
    df['time_past'] = time_list
    df['series_r'] = series_r_list
    df['pip_r'] = pip_r_list
    df['cell_type'] = cell_class_list
    return df

def current_indentation(df):
    grouped = df.groupby('indentation')
    max_current = []
    indentation_step = []
    capacitance_list = []
    time_post_list = []
    series_r_list = []
    pip_r_list = []
    cell_type_list = []
    for name, group in grouped:
        capacitance_list.append(group['capacitance'].max())
        time_post_list.append(group['time_past'].max())
        series_r_list.append(group['series_r'].max())
        pip_r_list.append(group['pip_r'].max())
        cell_type_list.append(group['cell_type'].max())
        group = group.loc[group['ti'].between(151,161)] #only needed if there is piezoelectric noise
        max_i = group['i'].max()
        max_current.append(max_i)
        indentation_step.append(name)
    df_indentation = pd.DataFrame({'current' : max_current,
                    'indentation' : indentation_step,
                    'capacitance' : capacitance_list,
                    'time_post' : time_post_list,
                    'series_r' : series_r_list,
                    'pip_r' : pip_r_list,
                    'cell_type' : cell_type_list})

    sns.lineplot(x = 'indentation', y = 'current', data = df_indentation)
    plt.show()

    return df_indentation

def tau_fit(df,  final_df):
    tau_list = []
    last_sweep = df['indentation'].max()
    df_tau = df.loc[df['indentation'] == last_sweep].reset_index().copy()
    max_index = df_tau['i'].idxmax()
    max_current = df_tau['i'].max() #used for initial guess for amplitude for the fit
    fit_start_time = df_tau['ti'][max_index]
    df_for_fit = df_tau.iloc[max_index:max_index + 500, ].copy() #sampliing at 10K so 500 datapoints is 50 ms
    df_for_fit['ti'] = df_for_fit['ti'] - fit_start_time #making peak time = 0


    def func(x, a, y0, tau):
    #x = datapoints, needs to be first paremeter in function
    #y0 = steady state current, may decay close to zero in poke
    #A = amplitude of the current
    #x0 = offset current (when the stimulus starts); taken care of already
        return y0 + a * math.e**(-(x)/tau)

    # xdata = np.array(df_for_fit['ti'])
    ydata = np.array(df_for_fit['i'])
    xdata = np.array(df_for_fit['ti'])


    guess_values = [max_current, 0, 5]

    #perform curve fit
    popt, pcov = curve_fit(func, xdata, ydata, guess_values)

    #add tau to list for dataframe
    tau_list.append(popt[-1])

#plot/plot fit data forfinal sweep to check fit
    fitline = np.linspace(0, 50, num = 1000)
    plt.plot(fitline, func(fitline, *popt), color = 'red')
    plt.plot(xdata, ydata, 'bo', label = 'experimentaldata', markersize=2)
    plt.show()
    
    final_df['tau'] = tau_list * len(final_df)
    return final_df

    
#################################################################################################################################


#################################################################################################################################
first_poke = 3
cap = 22.67
time_past = 25
series_r = 6.9
pip_r = 3.02
#1 = normal, 2 = differentiated
cell_class = 1


df = load_dataframe('Z:/All_Staff/Grandl Lab/Michael Sindoni/initial_frequency_screen/poke/2022_07_29_n2a_poke_10hz_OWG_maxamp_12.asc')

df_processed = parameter_processing(df, first_poke, cap, time_past, series_r, pip_r, cell_class)
print(df)

sns.lineplot(x = 'ti', y = 'i', data = df_processed, hue = 'sweep')
plt.show()

dfx = df_processed.loc[(df_processed['ti'] > 151) & (df_processed['ti'] < 300)]

df_current_indentation = current_indentation(df_processed)

df_tau = tau_fit(dfx, df_current_indentation)

df_tau.to_clipboard(excel=True, sep=None, index=False, header=None)


print(df_current_indentation)



#first making the raw p50 plots
